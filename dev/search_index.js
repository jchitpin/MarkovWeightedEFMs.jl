var documenterSearchIndex = {"docs":
[{"location":"tutorials/chmc-standard-ion-channels/#CHMC-(ion-channels)","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"","category":"section"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"This section demonstrates how to use the functions in MarkovWeightedEFMs.jl to analyze the steady state dynamics of the following ion channel with three possible binding sites reproduced from (Bicknell and Goodhill)[https://doi.org/10.1073/pnas.1604090113].","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"(Image: Markov chain model of IP3 receptor from Bicknell and Goodhill (https://doi.org/10.1073/pnas.1604090113))","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"using MarkovWeightedEFMs","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/#Markov-state-model-of-IP3-channel-activity","page":"CHMC (ion channels)","title":"Markov state model of IP3 channel activity","text":"","category":"section"},{"location":"tutorials/chmc-standard-ion-channels/#Rate-constants","page":"CHMC (ion channels)","title":"Rate constants","text":"","category":"section"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"using MarkovWeightedEFMs\n\n# Parameters\nc   = 0.1 # Ca2+ (uM)\nI   = 0.1 # IP3 (uM)\na1  = 50\na2  = 0.035\na4  = 3.5\na5  = 65\na6  = 25\na7  = 10\na8  = 0.035\na9  = 0.15\na10 = 1.25\na11 = 110\nb1  = 2.5\nb2  = 1.25\nb3  = 0.25\nb4  = 12.5\nb5  = 10\nb7  = 0.25\nb9  = 0.2\nb10 = 2.5\nb11 = 20\nK1  = b1 / a1\nK2  = b2 / a2\nK4  = b4 / a4\nK5  = b5 / a5\nK7  = b7 / a7\nK9  = b9 / a9\nK10 = b10 / a10\na3  = (b3 * K4) / (K1 * K2)\nb6  = (a6 * K5 * K7) / K1\nb8  = (a8 * K2 * K10) / K9\nnothing # hide","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/#Generator-and-transition-matrix","page":"CHMC (ion channels)","title":"Generator and transition matrix","text":"","category":"section"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"# Markov transition rate matrix\nQ = [#\n  0  c*a6 0    I*a7 0    0    0  0    0    0\n  b6 0    c*a4 0    I*a1 0    0  0    0    0\n  0  b4   0    0    0    I*a3 0  0    0    0\n  b7 0    0    0    c*a5 0    a9 0    0    0\n  0  b1   0    b5   0    c*a2 0  a9   0    a11\n  0  0    b3   0    b2   0    0  0    a10  0\n  0  0    0    b9   0    0    0  c*a5 0    0\n  0  0    0    0    b9   0    b5 0    c*a8 0\n  0  0    0    0    0    b10  0  b8   0    0\n  0  0    0    0    b11  0    0  0    0    0\n];\n\n# Markov transition probability matrix\nT = Q ./ sum(Q, dims=2)","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/#Enumerating-EFMs-and-computing-their-probabilities","page":"CHMC (ion channels)","title":"Enumerating EFMs and computing their probabilities","text":"","category":"section"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"The Markov state model contains 39 EFMs. If one were to simulate trajectories from this model for an infinite period of time and decompose these trajectories into simple cycles, the resulting frequencies would converge on the following EFM probabilities. For example, the active-inactive-active transition involving states 10-5-10 occurs ~83.8% of the time on average in this model.","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"res = steady_state_efm_distribution(T);\n\n# EFMs/simple cycles and their corresponding probabilities\nreduce(hcat, [res.e, res.p])","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/#Visualizing-the-CHMC","page":"CHMC (ion channels)","title":"Visualizing the CHMC","text":"","category":"section"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"The blue node represents state 1 and is the root of the tree. All green nodes return back to the blue node but these arrows are hidden to limit visual clutter.","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"using GLMakie\nGLMakie.activate!()\nplot_chmc(T, 1) # arbitrarily rooted on state 1","category":"page"},{"location":"tutorials/chmc-standard-ion-channels/","page":"CHMC (ion channels)","title":"CHMC (ion channels)","text":"(Image: )","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/#CHMC-(metabolic-networks)","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"","category":"section"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"This section demonstrates how to use the functions in MarkovWeightedEFMs.jl to analyze the following unimolecular reaction network.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"(Image: Example unimolecular reaction network)","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"using MarkovWeightedEFMs","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/#Problem-statement","page":"CHMC (metabolic networks)","title":"Problem statement","text":"","category":"section"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"Given the metabolic network above, its steady state fluxes, and its elementary flux modes (EFMs), what is the set of EFM weights that reconstructs the observed network fluxes?","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/#Inputs","page":"CHMC (metabolic networks)","title":"Inputs","text":"","category":"section"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"For this type of problem, we require the following:","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"Stoichiometry matrix of unimolecular reactions (must be unimolecular and strongly-connected; either open or closed loop)\nSteady state fluxes along each reaction.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The network metabolites and reactions are typically encoded in an m by r stoichiometry matrix S. The steady state flux vector is stored as a separate vector.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"using MarkovWeightedEFMs # load package\n\n# Stoichiometry matrix and flux vector for the example network\nS = [#\n -1  0  0  0  0  0  0  0  0  0  1\n  1 -1  1 -1  0  0  0  0  0  0  0\n  0  1 -1  0 -1  1  0  0  0  0  0\n  0  0  0  1  0  0 -1  0  0  0  0\n  0  0  0  0  1 -1  1 -1 -1  1  0\n  0  0  0  0  0  0  0  1  0  0 -1\n  0  0  0  0  0  0  0  0  1 -1  0\n]\nv = [3, 2, 1, 2, 3, 2, 2, 3, 1, 1, 3]\nnothing # hide","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"We can check that the flux vector satisfies the steady state requirements.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"all(S * v .== 0) # should evaluate as true","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/#Solving-for-EFM-sequences,-probabilities,-and-weights","page":"CHMC (metabolic networks)","title":"Solving for EFM sequences, probabilities, and weights","text":"","category":"section"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The following function applies our (discrete-time) cycle-history Markov chain (CHMC) method to compute the network EFMs, their steady state EFM probabilities, and weights. By default, the last parameter is 1 and can be omitted from the function. This parameter is the (arbitrary) initial state to root the CHMC. The choice of root state does not change the EFM probabilities or weights and is explained further in the section below.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"res = steady_state_efm_distribution(S, v, 1)","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The enumerated EFM sequences are","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"res.e","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The corresponding EFM probabilities are","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"res.p","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The corresponding EFM weights are","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"res.w","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"We can check that the EFM weights reconstruct the observed network fluxes","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"E = reshape_efm_vector(res.e, S) # matrix of EFM weights\nE * res.w ≈ v # passes","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"A binary EFM matrix with rows = # reactions and columns = # EFMs can be converted back to the array of EFM sequences by","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"reshape_efm_matrix(E, S)","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/#Visualizing-the-CHMC","page":"CHMC (metabolic networks)","title":"Visualizing the CHMC","text":"","category":"section"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The following plotting function visualizes the CHMC rooted on a metabolite state (1 by default).","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"using GLMakie # Makie backend\nGLMakie.activate!()\nT = stoichiometry_to_transition_matrix(S, v)\nplot_chmc(T, 1) # the last parameter is the rooted metabolite index","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"(Image: )","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"If using the GLMakie backend, ensure OpenGL is installed on your machine and accessible by Julia. The GLMakie plot is interactive and allows users to drag nodes and zoom in/out. Otherwise, you could choose another backend such as CairoMakie to generate and save a static plot. A prettier, hand-coded version of the transformed network is shown below.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"The blue node is the root of the tree and the green nodes indicate that there is an edge back up to the root. By default, these arrows are omitted to avoid cluttering the plot.","category":"page"},{"location":"tutorials/chmc-standard-metabolic-networks/","page":"CHMC (metabolic networks)","title":"CHMC (metabolic networks)","text":"(Image: )","category":"page"},{"location":"library/chmc-atomic/#Atomic-CHMC","page":"Atomic CHMC","title":"Atomic CHMC","text":"","category":"section"},{"location":"library/chmc-atomic/#Public-functions","page":"Atomic CHMC","title":"Public functions","text":"","category":"section"},{"location":"library/chmc-atomic/","page":"Atomic CHMC","title":"Atomic CHMC","text":"canonicalize_smiles\nfind_atomic_chmc_input_errors\ncorrect_atomic_chmc_input_errors\nprint(res::CHMCAtomicErrorSummary)\ncorrect_atomic_chmc_input_smiles\nexchange_atomic_chmc_input_metabolites\nget_source_metabolites\nget_max_atoms\nmap_reaction_strings\nprecompute_atom_tracing_dictionary\nMarkovWeightedEFMs.CHMC.Atomic.steady_state_efm_distribution(#\n    S::Matrix{<:Integer},\n    v::Vector{<:Real},\n    ms::Vector{String},\n    I::Tuple{Int64,Int64,Symbol};\n    D::Dict{#\n      NTuple{4,Int64},\n      Tuple{Int64,Int64}\n    }=Dict{NTuple{4,Int64}, Tuple{Int64,Int64}}(),\n    tmp_dir::String=\"\"\n)\nget_efm_metabolite_atom_indices\nget_efm_reaction_atom_indices\nchmc_to_mc_matrix\nexport_atom_tracing_dictionary\nimport_atom_tracing_dictionary","category":"page"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.canonicalize_smiles","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.canonicalize_smiles","text":"canonicalize_smiles(m::Vector{String})\n\nCanonicalize input SMILES string m for RXNMapper mapping.\n\n\n\n\n\ncanonicalize_smiles(m::String)\n\nCanonicalize input SMILES string m for RXNMapper mapping.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.find_atomic_chmc_input_errors","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.find_atomic_chmc_input_errors","text":"find_atomic_chmc_input_errors(S::Matrix{<:Real}, v::Vector{<:Real})\n\nPerforms a series of checks on stoichiometry matrix S and steady state flux vector v to determine whether they meet the atomic CHMC requirements. Returns an CHMCAtomicErrorSummary structure that can be printed via print(res::CHMCAtomicErrorSummary).\n\n\n\n\n\nfind_atomic_chmc_input_errors(S::Matrix{<:Real})\n\nPerforms a series of checks on stoichiometry matrix S to determine whether they meet the atomic CHMC requirements for atomic EFM enumeration. Returns an CHMCAtomicErrorSummary structure that can be printed via print(res::CHMCAtomicErrorSummary).\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.correct_atomic_chmc_input_errors","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.correct_atomic_chmc_input_errors","text":"correct_atomic_chmc_input_errors(#\n    res::CHMCAtomicErrorSummary,\n    S::Matrix{<:Real},\n    v::Vector{<:Real},\n    mets::Vector{String},\n    rxns::Vector{String}\n)\n\nCorrects all errors identified by find_atomic_chmc_input_errors except for the steady state flux requirement. Returns a corrected version of each input.\n\nS is the m by n stoichiometry matrix. v is the steady state flux vector of length n. mets is the vector of metabolite names of length m. rxns is the vector of reaction names of length n.\n\n\n\n\n\ncorrect_atomic_chmc_input_errors(#\n    res::CHMCAtomicErrorSummary,\n    S::Matrix{<:Real},\n    mets::Vector{String},\n    rxns::Vector{String}\n)\n\nCorrects all errors identified by find_atomic_chmc_input_errors except for the steady state flux requirement. Returns a corrected version of each input.\n\nS is the m by n stoichiometry matrix. mets is the vector of metabolite names of length m. rxns is the vector of reaction names of length n.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#Base.print-Tuple{CHMCAtomicErrorSummary}","page":"Atomic CHMC","title":"Base.print","text":"print(res::CHMCAtomicErrorSummary)\n\nWrite CHMCAtomicErrorSummary to stdout.\n\n\n\n\n\n","category":"method"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.correct_atomic_chmc_input_smiles","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.correct_atomic_chmc_input_smiles","text":"correct_atomic_chmc_input_smiles(#\n    S::Matrix{<:Real},\n    v::Vector{<:Real},\n    mets::Vector{String},\n    rxns::Vector{String},\n    smiles::Vector{String},\n    H::Bool=false\n)\n\nUpdates the inputs by (1) removing pseudometabolites and (2) reactions whose reaction strings exceed the RXNMapper character limit. Pseudometabolites are defined as either metabolites with no defined chemical structure/SMILES representation, or metabolites whose SMILES strings contain symbols absent from the periodic table (including metabolites with an R-group). Reactions that exceed the RXNMapper character limit are converted into unimolecular sources and sinks to maintain steady state flux. Returns the corrected inputs with a list of removed metabolites/reactions.\n\nS is the m by n stoichiometry matrix.\n\nv is the steady state flux vector of length n.\n\nmets is the vector of metabolite names of length m.\n\nrxns is the vector of reaction names of length n.\n\nsmiles is the vector of metabolite smiles matching mets.\n\nH = false will not check for hydrogen conservation in each reaction.\n\n\n\n\n\ncorrect_atomic_chmc_input_smiles(#\n    S::Matrix{<:Real},\n    mets::Vector{String},\n    rxns::Vector{String},\n    smiles::Vector{String},\n    H::Bool=false\n)\n\nUpdates the inputs by (1) removing pseudometabolites and (2) reactions whose reaction strings exceed the RXNMapper character limit. Pseudometabolites are defined as either metabolites with no defined chemical structure/SMILES representation, or metabolites whose SMILES strings contain symbols absent from the periodic table (including metabolites with an R-group). Reactions that exceed the RXNMapper character limit are converted into unimolecular sources and sinks to maintain steady state flux. Returns the corrected inputs with a list of removed metabolites/reactions.\n\nS is the m by n stoichiometry matrix.\n\nmets is the vector of metabolite names of length m.\n\nrxns is the vector of reaction names of length n.\n\nsmiles is the vector of metabolite smiles matching mets.\n\nH = false will not check for hydrogen conservation in each reaction.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.exchange_atomic_chmc_input_metabolites","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.exchange_atomic_chmc_input_metabolites","text":"exchange_atomic_chmc_input_metabolites(#\n    S::Matrix{<:Real},\n    v::Vector{<:Real},\n    mets::Vector{String},\n    rxns::Vector{String},\n    smiles::Vector{String},\n    ii::Vector{Int64}\n)\n\nRemoves internal metabolites ii from the remaining inputs by converting each metabolite i ∈ ii into a pair of sink and source metabolites. Returns an updated copy of inputs S, v, mets, rxns, and smiles.\n\nS is the m by n stoichiometry matrix.\n\nv is the steady state flux vector of length n.\n\nmets is the vector of metabolite names of length m.\n\nrxns is the vector of reaction names of length n.\n\nsmiles is the vector of metabolite smiles matching mets.\n\nii is the vector of metabolite indices to exchange for pairs of sinks/sources.\n\n\n\n\n\nexchange_atomic_chmc_input_metabolites(#\n    S::Matrix{<:Real},\n    mets::Vector{String},\n    rxns::Vector{String},\n    smiles::Vector{String},\n    ii::Vector{Int64}\n)\n\nRemoves internal metabolites ii from the remaining inputs by converting each metabolite i ∈ ii into a pair of sink and source metabolites. Returns an updated copy of inputs S, mets, rxns, and smiles.\n\nS is the m by n stoichiometry matrix.\n\nmets is the vector of metabolite names of length m.\n\nrxns is the vector of reaction names of length n.\n\nsmiles is the vector of metabolite smiles matching mets.\n\nii is the vector of metabolite indices to exchange for pairs of sinks/sources.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.get_source_metabolites","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.get_source_metabolites","text":"get_source_metabolites(S::Matrix{Int16})\n\nReturns a vector of all source metabolites in stoichiometry matrix S.\n\nS is the m by n stoichiometry matrix.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.get_max_atoms","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.get_max_atoms","text":"get_max_atoms(s::Vector{String}, a::Symbol)\n\nReturns the maximum number of atoms of type a for each SMILES string in s. Returns a vector of all source metabolites in stoichiometry matrix S.\n\ns is the vector of metabolite SMILES strings.\n\na is a periodic table element symbol.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.map_reaction_strings","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.map_reaction_strings","text":"map_reaction_strings(#\n    S::Matrix{<:Real},\n    smiles::Vector{String},\n    rxns::Vector{String},\n    H::Bool=false\n)\n\nConstructs reaction strings from the smiles and then returns the atom-mapped reaction strings via RXNMapper.\n\nS is the stoichiometry matrix.\n\nsmiles is the vector of SMILES strings for metabolites in S.\n\nrxns is the vector of reaction names in S.\n\nH = false will not check for hydrogen conservation in each reaction.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.precompute_atom_tracing_dictionary","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.precompute_atom_tracing_dictionary","text":"precompute_atom_tracing_dictionary(#\n    S::Matrix{Int16},\n    ms::Vector{String},\n    amax::Vector{Int64},\n    a::Symbol\n)\n\nPrecomputes a dictionary mapping each atom in a given substrate stoichiometric copy to its product atom across every reaction. The dictionary is used in steady_state_efm_distribution.\n\nS is the stoichiometry matrix.\n\nms is the vector of mapped reaction SMILES strings.\n\namax is the total number of atom a in each metabolite row of S.\n\na is a periodic table element symbol.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution-Tuple{Matrix{<:Integer}, Vector{<:Real}, Vector{String}, Tuple{Int64, Int64, Symbol}}","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution","text":"steady_state_efm_distribution(#\n    S::Matrix{<:Integer},\n    v::Vector{<:Real},\n    ms::Vector{String},\n    I::Tuple{Int64,Int64,Symbol};\n    D::Dict{#\n      NTuple{4,Int64},\n      Tuple{Int64,Int64}\n    } = Dict{NTuple{4,Int64}, Tuple{Int64,Int64}}(),\n    solver = nothing,\n    verbose::Bool = true\n)\n\nEnumerates the atomic EFMs from stoichiometry matrix S and compute the steady state probabilities of each EFM according to the discrete-time, cycle-history Markov chain.\n\nS is a fully-connected, unimolecular, m by n stoichiometry matrix with m metabolites and n reactions.\n\nv is the n-length steady state flux vector associated with S.\n\nms is the vector of mapped reaction SMILES strings.\n\nI is a triplet of the metabolite row index in S, the atom index, and the atom index type. It is the initial starting state for rooting the cycle-history Markov chain.\n\nD is the precomputed dictionary from precompute_atom_tracing_dictionary. Specifying D greatly speeds up the atomic CHMC construction.\n\nsolver is the type used for eigenvector calculations. Default is nothing and LinearSolve will pick the best solver. Consult LinearSolve.jl for  specifying other solvers.\n\n\n\n\n\n","category":"method"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.get_efm_metabolite_atom_indices","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.get_efm_metabolite_atom_indices","text":"get_efm_metabolite_atom_indices(res::CHMCAtomicSummary, i::Int64)\n\nConverts the sequence of metabolite indices for atomic EFM index i into metabolite names. The length of the vector of metabolite names is one element shorter than res.e[i] because the pseudometabolite connecting sink and source reactions is omitted.\n\nres are the results from steady_state_efm_distribution.\n\ni is the index for a given EFM.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.get_efm_reaction_atom_indices","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.get_efm_reaction_atom_indices","text":"get_efm_reaction_indices(res::CHMCAtomicSummary, i::Int64)\n\nConverts the sequence of metabolite indices for atomic EFM index i into reaction names. \n\nres are the results from steady_state_efm_distribution.\n\ni is the index for a given EFM.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.chmc_to_mc_matrix","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.chmc_to_mc_matrix","text":"chmc_to_mc_matrix(res::CHMCAtomicSummary, v::Vector{<:Real})\n\nConverts CHMC transition matrix res.T to a Markov chain with probabilities taken from steady state flux vector v.\n\nres are the results from steady_state_efm_distribution.\n\nv is the steady state flux vector used as input from steady_state_efm_distribution.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.export_atom_tracing_dictionary","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.export_atom_tracing_dictionary","text":"export_atom_tracing_dictionary(#\n    fname::String,\n    D::Dict{NTuple{4, Int64}, Tuple{Int64, Int64}}\n)\n\nExport atom tracing dictionary D to text file fname.\n\nfname is the filename to write the atom tracing dictionary results.\n\nD is the dictionary from precompute_atom_tracing_dictionary.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#MarkovWeightedEFMs.CHMC.Atomic.import_atom_tracing_dictionary","page":"Atomic CHMC","title":"MarkovWeightedEFMs.CHMC.Atomic.import_atom_tracing_dictionary","text":"import_atom_tracing_dictionary(fname::String)\n\nImport atomic tracing dictionary from text file fname.\n\nfname is the filename containing the atom tracing dictionary results.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-atomic/#Index","page":"Atomic CHMC","title":"Index","text":"","category":"section"},{"location":"library/chmc-atomic/","page":"Atomic CHMC","title":"Atomic CHMC","text":"Pages = [\"chmc-atomic.md\"]","category":"page"},{"location":"library/chmc-plots-standard/#Plotting-(CHMC)","page":"Plotting (CHMC)","title":"Plotting (CHMC)","text":"","category":"section"},{"location":"library/chmc-plots-standard/#CHMC","page":"Plotting (CHMC)","title":"CHMC","text":"","category":"section"},{"location":"library/chmc-plots-standard/","page":"Plotting (CHMC)","title":"Plotting (CHMC)","text":"plot_chmc","category":"page"},{"location":"library/chmc-plots-standard/#MarkovWeightedEFMs.Plots.plot_chmc","page":"Plotting (CHMC)","title":"MarkovWeightedEFMs.Plots.plot_chmc","text":"function plot_chmc(#\n    T::Matrix{<:Real},\n    I::Int64=1;\n    node_label_textsize::Real=15,\n    edge_label_textsize::Real=12,\n    arrow_shift::Real=0.85,\n    x_pad::Real=0.75,\n    y_pad::Real=0.75,\n    tfactor::Real=0.15,\n    tangents::Tuple{#\n        Tuple{<:Real, <:Real},\n        Tuple{<:Real, <:Real}\n    } = ((1,0),(0,1)),\n    show_all::Bool=false\n\n)\n\nPlot cycle-history Markov chain from transition probability matrix T rooted on state/node I.\n\nT is a right stochastic transition probability matrix with rows summing to one.\n\nI is a state in 1:size(T,1).\n\nnode_label_textsize is the text size of the node labels indexed from T.\n\nedge_label_textsize is the text size of the edge labels taken from T.\n\narrow_shift is the percentage shift of the arrow head from src to dst.\n\nx_pad is the left/right x coordinate padding of the plotting box.\n\ny_pad is the up/down y coordinate padding of the plotting box.\n\ntfactor scales the distance of the bezier control point relative to the distance of the src and dst nodes.\n\ntangents is the tangent of the src vertex and dst vertex.\n\nshow_all=true explicitly plots the upstream transition from all EFMs that pass through the initial state/node I. By default, these arrows stemming from the green nodes are omitted for visual clarity.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-plots-standard/#Index","page":"Plotting (CHMC)","title":"Index","text":"","category":"section"},{"location":"library/chmc-plots-standard/","page":"Plotting (CHMC)","title":"Plotting (CHMC)","text":"Pages = [\"chmc-plots.md\"]","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/#Boilerplate-code-for-ACHMC-analysis-of-BiGG-models","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"","category":"section"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"The following code is provided to quickly construct ACHMC models of BiGG metabolic models and others stored in the SBML file format. Each code block is designed to be standalone with calculations saved to file and re-loaded in a subsequent code block. Unfortunately, BiGG does not store SMILES strings so these will need to be manually compiled by the user.","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"Note we recommend starting with relatively small networks (<500 metabolites and reactions in the original metabolic model) for computational feasibility.","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/#Inputs-(from-BiGG)","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Inputs (from BiGG)","text":"","category":"section"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"This section shows how to extract relevant information from a BiGG metabolic model called e_coli_core.xml","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"# Import file names\nim_sbml = \"e_coli_core.xml\"\n\n# Export file names\nex_stoich                   = \"stoich.csv\"\nex_metabolites_compartments = \"metabolites-compartments.csv\"\nex_reactions                = \"reactions.csv\"\nex_formulas                 = \"metabolite-formulas.csv\"\n\n# Packages\nusing SBML, CSV, Tables\n\n# Load SBML model\nmdl = readSBML(im_sbml)\nmetabolites, reactions, S = stoichiometry_matrix(mdl)\n\n# Dense stoichiometry matrix\nS = Array(S)\n\n# Metabolite names\nmets = [mdl.species[m].name for m in metabolites]\nmets = replace.(mets, \" \" => \"_\")\n\n# Metabolite names concatenated with compartment\nmetsc = [#\n    join([mdl.species[m].name, mdl.species[m].compartment], \"_\")\n    for m in metabolites\n]\nmetsc = replace.(metsc, \" \" => \"_\")\n\n# Metabolite formulas\nformulas = [mdl.species[m].formula for m in metabolites]\nformulas[isnothing.(formulas)] .= \"\"\n\n# Reaction names\nrxns = [mdl.reactions[r].name for r in reactions]\n\n# Export to text file\nCSV.write(ex_stoich, Tables.table(S), header = false)\nCSV.write(ex_metabolites, Tables.table(mets), header = false)\nCSV.write(ex_metabolites_compartments, Tables.table(metsc), header = false)\nCSV.write(ex_reactions, Tables.table(rxns), header = false)\nCSV.write(ex_formulas, Tables.table(formulas), header = false)","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/#Pre-processing-inputs-(for-AEFM-enumeration)","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Pre-processing inputs (for AEFM enumeration)","text":"","category":"section"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"This section pre-processes the BiGG inputs to meet the ACHMC requirements.","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"# Import file names\nim_stoich = \"stoich.csv\"\nim_mets   = \"metabolites-compartments.csv\"\nim_rxns   = \"reactions.csv\"\nim_smiles = \"smiles-isomeric.csv\"\n\n# Export file names\nex_stoich = \"stoichiometry-matrix-processed.csv\"\nex_mets   = \"metabolites-processed.csv\"\nex_rxns   = \"reactions-processed.csv\"\nex_smiles = \"smiles-isomeric-processed.csv\"\nex_reaction_smiles        = \"reaction-smiles-processed.csv\"\nex_mapped_reaction_smiles = \"mapped-reaction-smiles-strings-processed.csv\"\nex_dict_carbon            = \"dictionary-atom-tracing-carbon.csv\"\n\n# Packages\nusing CSV, Tables, MarkovWeightedEFMs, BenchmarkTools\n\n## Load previous inputs\n# Stoichiometry matrix\nS = CSV.read(im_stoich, Tables.matrix, header = false)\n\n# Metabolites\nmets = vec(CSV.read(im_mets, Tables.matrix, header = false))\n\n# Reactions\nrxns = String.(vec(CSV.read(im_rxns, Tables.matrix, header = false)))\n\n## Pre-processing\n# (1) Identify problems with S/v inputs\nerrors = find_atomic_chmc_input_errors(S)\nprint(errors) # summary of errors associated with S\n\n# (2) Clean S inputs\nS2, mets2, rxns2 = correct_atomic_chmc_input_errors(errors, S, mets, rxns)\nprint(find_atomic_chmc_input_errors(S2)) # confirm errors have been fixed\n\n# (3) Construct vector of smiles corresponding to the remaining metabolites in S\n# The SMILES strings for pseudometabolites with no defined chemical structure\n# are given an arbitrary SMILES of 'R' (or character that does not represent\n# a periodic table element)\n# SMILES strings matching S2\nsmiles3 = vec(CSV.read(im_smiles, Tables.matrix, header = false))\n\n# (4) Remove pseudometabolites and reactions exceeding RXNMapper character limit\nS4, mets4, rxns4, smiles4, i4 = correct_atomic_chmc_input_smiles(#\n  S2, mets2, rxns2, smiles3\n)\ni4.dropped_rows_pseudometabolites # pseudometabolite rows removed from S2\ni4.dropped_cols_pseudometabolites # pseudometabolite reactions removed from S2\ni4.dropped_cols_rxnmapper_limit # reactions in S2 removed bc of RXNMapper limit\nprint(find_atomic_chmc_input_errors(S4)) # confirm no errors\n\n# (5) Construct the reaction strings and map atoms via RXNMAPPER\nsmiles5 = canonicalize_smiles(smiles4) # smiles strings must be canonicalized!\nrs5, ms5 = map_reaction_strings(S4, smiles5, rxns4, false)\n\n# (6) Precompute atom tracing dictionary (for carbons)\namax = get_max_atoms(smiles5, :C)\nD_C = precompute_atom_tracing_dictionary(S4, ms5, amax, :C)\n\n# Export to text file\nCSV.write(ex_stoich, Tables.table(S4), header = false)\nCSV.write(ex_mets, Tables.table(mets4), header = false)\nCSV.write(ex_rxns, Tables.table(rxns4), header = false, quotestrings = true)\nCSV.write(ex_smiles, Tables.table(smiles5), header = false)\nCSV.write(ex_reaction_smiles, Tables.table(rs5), header = false)\nCSV.write(ex_mapped_reaction_smiles, Tables.table(ms5), header = false)\nCSV.write(ex_dict_carbon, D_C, header = false)","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/#Pre-processing-inputs-(for-AEFM-weight-assignment)","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Pre-processing inputs (for AEFM weight assignment)","text":"","category":"section"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"Assuming there is a steady state flux vector v, the pre-processing steps are slightly different:","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"## Pre-processing\n# (1) Identify problems with S/v inputs\nerrors = find_atomic_chmc_input_errors(S, v)\nprint(errors) # summary of errors associated with S/v\n\n# (2) Clean S/v inputs\nS2, v2, mets2, rxns2 = correct_atomic_chmc_input_errors(errors, S, v, mets, rxns)\nprint(find_atomic_chmc_input_errors(S2, v2)) # confirm errors have been fixed\n\n# (3) Construct vector of smiles corresponding to the remaining metabolites in S\nsmiles3 = vec(CSV.read(im_smiles, Tables.matrix, header = false))\n\n# (4) Remove pseudometabolites and reactions exceeding RXNMapper character limit\nS4, v4, mets4, rxns4, smiles4, i4 = correct_atomic_chmc_input_smiles(#\n  S2, v2, mets2, rxns2, smiles3\n)\ni4.dropped_rows_pseudometabolites # 33 pseudometabolite rows removed from S2\ni4.dropped_cols_pseudometabolites # 46 pseudometabolite reactions removed from S2\ni4.dropped_cols_rxnmapper_limit # 3 reactions in S2 removed bc of RXNMapper limit\nprint(find_atomic_chmc_input_errors(S4, v4)) # confirm no errors\n\n# (5) Construct the reaction strings and map atoms via RXNMAPPER\nsmiles5 = canonicalize_smiles(smiles4) # smiles strings must be canonicalized!\nrs5, ms5 = map_reaction_strings(S4, smiles5, rxns, false)\n\n# (6) Precompute atom tracing dictionary (for carbons)\namax = get_max_atoms(smiles5, :C)\nD_C = precompute_atom_tracing_dictionary(S4, ms5, amax, :C)","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/#Enumerating-AEFMs-across-all-source-metabolite-carbons","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Enumerating AEFMs across all source metabolite carbons","text":"","category":"section"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"# Verbosity of AEFM enumeration function (provides a progress meter)\nverbose = true\n\n# File names\nstoich_loc = \"stoichiometry-matrix-processed.csv\"\nsmiles_loc = \"smiles-isomeric-processed.csv\"\nmets_loc   = \"metabolites-processed.csv\"\nD_C_loc    = \"dictionary-atom-tracing-carbon.csv\"\nD_N_loc    = \"dictionary-atom-tracing-nitrogen.csv\"\nms_loc     = \"mapped-reaction-smiles-strings-processed.csv\"\nrxns_loc   = \"reactions-processed.csv\"\n\n# Packages\nusing CSV, Tables, MarkovWeightedEFMs, JLD2, Dates\n\n## Load final data\n# Load stoichiometry matrix\nS = Int16.(CSV.read(stoich_loc, Tables.matrix, header = false))\n\n# Load SMILES strings matching the stoichiometry rows\nsmiles = vec(CSV.read(smiles_loc, Tables.matrix, header = false))\n\n# Load metabolites\nmets = vec(CSV.read(mets_loc, Tables.matrix, header = false))\n\n# Load atom tracing dictionary\nD_C = import_atom_tracing_dictionary(D_C_loc)\n\n# Load mapped reaction smiles strings\nms = vec(CSV.read(#\n    ms_loc, Tables.matrix, delim = ';', ignoreemptyrows = false, header = false\n))\ng(x) = ismissing(x) ? \"\" : x\nms = g.(ms)\n\n# Load reactions\nrxns = String.(vec(CSV.read(rxns_loc, Tables.matrix, header = false)))\n\n## Enumerate atomic efms\n# Identify indices of all source metabolites and number of carbons/nitrogens\nsrcs = get_source_metabolites(Int16.(S))\namax_C = get_max_atoms(smiles, :C)\n\nstart_time = Dates.now()\nfor k in eachindex(srcs)\n    res_dir = \"$k-\" * mets[srcs[k]]\n    isdir(res_dir) || mkdir(res_dir)\n    for l in 1:amax_C[srcs[k]]\n        I = (srcs[k], l, :C)\n        res = enumerate_atomic_efms(S, ms, I, D_C; verbose = verbose)\n    end\nend\nend_time = Dates.now()\nttime = end_time - start_time\n\n@info \"It took $ttime to enumerate all carbon AEFMs.\"","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/#Computing-AEFM-weights-across-all-source-metabolite-carbons","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Computing AEFM weights across all source metabolite carbons","text":"","category":"section"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"Decomposing fluxes onto AEFMs uses the function steady_state_efm_distribution() requires the steady state fluxes v:","category":"page"},{"location":"tutorials/boilerplate-for-bigg-gems/","page":"Boilerplate code for ACHMC analysis of BiGG models","title":"Boilerplate code for ACHMC analysis of BiGG models","text":"for k in eachindex(srcs)\n    res_dir = \"$k-\" * mets[srcs[k]]\n    isdir(res_dir) || mkdir(res_dir)\n    for l in 1:amax_C[srcs[k]]\n        I = (srcs[k], l, :C)\n        res = steady_state_efm_distribution(S, v, ms, I, D_C; verbose = verbose)\n    end\nend","category":"page"},{"location":"library/chmc-plots-atomic/#Plotting-(ACHMC)","page":"Plotting (ACHMC)","title":"Plotting (ACHMC)","text":"","category":"section"},{"location":"library/chmc-plots-atomic/#Atomic-CHMC","page":"Plotting (ACHMC)","title":"Atomic CHMC","text":"","category":"section"},{"location":"library/chmc-plots-atomic/","page":"Plotting (ACHMC)","title":"Plotting (ACHMC)","text":"plot_mapped_reaction\nplot_atomic_chmc","category":"page"},{"location":"library/chmc-plots-atomic/#MarkovWeightedEFMs.Plots.plot_mapped_reaction","page":"Plotting (ACHMC)","title":"MarkovWeightedEFMs.Plots.plot_mapped_reaction","text":"function plot_mapped_reaction(#\n    s::String,\n    fname::String = \"\";\n    view::Bool = false,\n    canvas_width::Int64 = 3000,\n    canvas_height::Int64 = 1000\n\n)\n\nPlot mapped reaction SMILES string s as an SVG and save to fname if specified.\n\ncanvas_width is the width of the SVG.\n\ncanvas_height is the height of the SVG.\n\nview=true will plot the SVG assuming a plotting backend is specified. For example, loading the ElectronDisplay package will plot the SVG to an Electron window.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-plots-atomic/#MarkovWeightedEFMs.Plots.plot_atomic_chmc","page":"Plotting (ACHMC)","title":"MarkovWeightedEFMs.Plots.plot_atomic_chmc","text":"function plot_atomic_chmc(#\n    res::CHMCAtomicSummary,\n    S::Matrix{Int16},\n    mets::Vector{String},\n    rs::Vector{String};\n    node_label_textsize::Real=15,\n    edge_label_textsize::Real=12,\n    arrow_shift::Real=0.85,\n    x_pad::Real=0.75,\n    y_pad::Real=0.75,\n    tfactor::Real=0.15,\n    tangents::Tuple{#\n        Tuple{<:Real, <:Real},\n        Tuple{<:Real, <:Real}\n    } = ((1,0),(0,1)),\n    show_all::Bool=false,\n    width::Int64=620,\n    height::Int64=310\n\n)\n\nPlot atomic cycle-history Markov chain.\n\nS is the m by n stoichiometry matrix.\n\nmets is the vector of metabolite names of length m.\n\nrs is the vector of reaction SMILES strings of length n.\n\nnode_label_textsize is the text size of the node labels indexed from T.\n\nedge_label_textsize is the text size of the edge labels taken from T.\n\narrow_shift is the percentage shift of the arrow head from src to dst.\n\nx_pad is the left/right x coordinate padding of the plotting box.\n\ny_pad is the up/down y coordinate padding of the plotting box.\n\ntfactor scales the distance of the bezier control point relative to the distance of the src and dst nodes.\n\ntangents is the tangent of the src vertex and dst vertex.\n\nshow_all=true explicitly plots the upstream transition from all EFMs that pass through the initial state/node I. By default, these arrows stemming from the green nodes are omitted for visual clarity.\n\nwidth and height specify the plotting window dimensions in pixel units.\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-plots-atomic/#Index","page":"Plotting (ACHMC)","title":"Index","text":"","category":"section"},{"location":"library/chmc-plots-atomic/","page":"Plotting (ACHMC)","title":"Plotting (ACHMC)","text":"Pages = [\"chmc-plots.md\"]","category":"page"},{"location":"library/chmc-standard/#CHMC","page":"CHMC","title":"CHMC","text":"","category":"section"},{"location":"library/chmc-standard/#Public-functions","page":"CHMC","title":"Public functions","text":"","category":"section"},{"location":"library/chmc-standard/","page":"CHMC","title":"CHMC","text":"MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution(S::Matrix{<:Integer}, v::Vector{<:Real}, I::Int64=1)\nMarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution(T::Matrix{<:Real}, I::Int64=1)\nstoichiometry_to_transition_matrix\nreshape_efm_matrix\nreshape_efm_vector","category":"page"},{"location":"library/chmc-standard/#MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution","page":"CHMC","title":"MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution","text":"steady_state_efm_distribution(#\n    S::Matrix{<:Integer},\n    v::Vector{<:Real},\n    I::Int64 = 1;\n    solver = nothing,\n    issparse::Bool = false\n)\n\nEnumerate the EFMs from stoichiometry matrix S and compute the steady state probabilities of each EFM according to the discrete-time, cycle-history Markov chain.\n\nS is a fully-connected, unimolecular, m by n stoichiometry matrix with m metabolites and n reactions.\n\nv is the n-length steady state flux vector associated with S.\n\nI is the initial starting state for rooting the cycle-history Markov chain. The choice of initial starting state does not affect the steady state EFM probabilities. The default is 1 and must be a whole number between 1:m.\n\nsolver is the type used for eigenvector calculations. Default is nothing and LinearSolve will pick the best solver. Consult LinearSolve.jl for  specifying other solvers.\n\nissparse is true will use a sparse transition probability for the CHMC to save memory.\n\nExample\n\njulia> S = [#\n -1  0  0  0  0  0  0  0  0  0  1\n  1 -1  1 -1  0  0  0  0  0  0  0\n  0  1 -1  0 -1  1  0  0  0  0  0\n  0  0  0  1  0  0 -1  0  0  0  0\n  0  0  0  0  1 -1  1 -1  1 -1  0\n  0  0  0  0  0  0  0  0  0  1 -1\n  0  0  0  0  0  0  0  1 -1  0  0\n];\njulia> v = [3, 2, 1, 2, 3, 2, 2, 1, 1, 3, 3];\njulia> res = steady_state_efm_distribution(S, v);\njulia> res.e # EFM state sequences\n6-element Vector{Vector{Int64}}:\n [3, 2, 3]\n [3, 2, 4, 5, 3]\n [3, 5, 3]\n [6, 1, 2, 4, 5, 6]\n [7, 5, 7]\n [6, 1, 2, 3, 5, 6]\n\njulia> res.p # EFM probabilities\n6-element Vector{Float64}:\n 0.10638297872340426\n 0.0425531914893617\n 0.25531914893617025\n 0.1914893617021277\n 0.14893617021276595\n 0.25531914893617025\n\njulia> res.w # EFM weights\n6-element Vector{Float64}:\n 0.7142857142857142\n 0.2857142857142857\n 1.7142857142857144\n 1.2857142857142858\n 0.9999999999999999\n 1.7142857142857144\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-standard/#MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution-2","page":"CHMC","title":"MarkovWeightedEFMs.CHMC.Standard.steady_state_efm_distribution","text":"steady_state_efm_distribution(#\n    T::Union{Matrix{<:Real}, SparseMatrixCSC{Float64, Int64}},\n    I::Int64 = 1;\n    solver = nothing,\n    verbose::Bool = true\n)\n\nEnumerate the EFMs from (right) transition probability matrix T whose rows sum to one, and compute the steady state probabilities of each EFM according to the discrete-time, cycle-history Markov chain.\n\nT is the discrete-time transition probability matrix with probabilities proportional to the outgoing fluxes.\n\nI is the initial starting state for rooting the cycle-history Markov chain. The choice of initial starting state does not affect the steady state EFM probabilities. The default is 1 and must be a whole number between 1:m.\n\nsolver is the type used for eigenvector calculations. Default is nothing and LinearSolve will pick the best solver. Consult LinearSolve.jl for  specifying other solvers.\n\nExample\n\njulia> T = [#\n  0.0  1.0   0.0       0.0  0.0   0.0  0.0\n  0.0  0.0   0.5       0.5  0.0   0.0  0.0\n  0.0  0.25  0.0       0.0  0.75  0.0  0.0\n  0.0  0.0   0.0       0.0  1.0   0.0  0.0\n  0.0  0.0   0.333333  0.0  0.0   0.5  0.166667\n  1.0  0.0   0.0       0.0  0.0   0.0  0.0\n  0.0  0.0   0.0       0.0  1.0   0.0  0.0\n];\njulia> res = steady_state_efm_distribution(T);\njulia> res.e # EFM state sequences\n6-element Vector{Vector{Int64}}:\n [3, 2, 3]\n [3, 2, 4, 5, 3]\n [3, 5, 3]\n [6, 1, 2, 3, 5, 6]\n [7, 5, 7]\n [6, 1, 2, 4, 5, 6]\n\njulia> res.p # EFM probabilities\n6-element Vector{Float64}:\n 0.13723110896294213\n 0.035797649943428565\n 0.26989203316869914\n 0.20302350628312624\n 0.13926980198123254\n 0.2147858996605714\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-standard/#MarkovWeightedEFMs.CHMC.Standard.stoichiometry_to_transition_matrix","page":"CHMC","title":"MarkovWeightedEFMs.CHMC.Standard.stoichiometry_to_transition_matrix","text":"stoichiometry_to_transition_matrix(S::Matrix{<:Integer}, v::Vector{<:Real})\n\nConvert stoichiometry matrix S with vector of steady state fluxes to a right stochastic transition probability matrix with rows summing to one.\n\nS is the m by n stoichiometry matrix with m metabolites and n reactions.\n\nv is the steady state flux vector with length n.\n\nExamples\n\njulia> S = [#\n  -1  0  0  0  0  0  0  0  0  0  1\n   1 -1  1 -1  0  0  0  0  0  0  0\n   0  1 -1  0 -1  1  0  0  0  0  0\n   0  0  0  1  0  0 -1  0  0  0  0\n   0  0  0  0  1 -1  1 -1 -1  1  0\n   0  0  0  0  0  0  0  1  0  0 -1\n   0  0  0  0  0  0  0  0  1 -1  0\n]\njulia> v = [2, 2, 2, 2, 2, 2, 2, 2, 4]\njulia> stoich_to_transition(S, v)\n7x7 Matrix{Float64}:\n 0.0  1.0   0.0       0.0  0.0   0.0  0.0\n 0.0  0.0   0.5       0.5  0.0   0.0  0.0\n 0.0  0.25  0.0       0.0  0.75  0.0  0.0\n 0.0  0.0   0.0       0.0  1.0   0.0  0.0\n 0.0  0.0   0.333333  0.0  0.0   0.5 0.166667\n 1.0  0.0   0.0       0.0  0.0   0.0  0.0\n 0.0  0.0   0.0       0.0  1.0   0.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-standard/#MarkovWeightedEFMs.CHMC.Standard.reshape_efm_matrix","page":"CHMC","title":"MarkovWeightedEFMs.CHMC.Standard.reshape_efm_matrix","text":"reshape_efm_matrix(ϕ::Matrix{Int64}, S::Matrix{<:Real})\n\nConvert a matrix of EFMs ϕ to a nested vector of EFMs from a stoichiometry matrix S. Stoichiometry matrix may only contain unimolecular reactions.\n\nϕ is the n by k EFM matrix with n reactions (rows) and k EFMs (cols).\n\nS is the m by n stoichiometry matrix with m metabolites (rows) and n reactions (cols).\n\nExamples\n\njulia> ϕ = [#\n  1  1  0  0  0  0\n  1  0  1  0  0  0\n  0  0  1  0  0  1\n  0  1  0  0  0  1\n  1  0  0  1  0  0\n  0  0  0  1  0  1\n  0  1  0  0  0  1\n  1  1  0  0  0  0\n  0  0  0  0  1  0\n  0  0  0  0  1  0\n  1  1  0  0  0  0\n]\njulia> S = [#\n  -1  0  0  0  0  0  0  0  0  0  1\n   1 -1  1 -1  0  0  0  0  0  0  0\n   0  1 -1  0 -1  1  0  0  0  0  0\n   0  0  0  1  0  0 -1  0  0  0  0\n   0  0  0  0  1 -1  1 -1 -1  1  0\n   0  0  0  0  0  0  0  1  0  0 -1\n   0  0  0  0  0  0  0  0  1 -1  0\n]\njulia> efm_vector = reshape_efm_matrix(ϕ, S)\n6-element Vector{Vector{Int64}}:\n [1, 2, 3, 5, 6, 1]\n [1, 2, 4, 5, 6, 1]\n [2, 3, 2]\n [3, 5, 3]\n [5, 7, 5]\n [3, 2, 4, 5, 3]\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-standard/#MarkovWeightedEFMs.CHMC.Standard.reshape_efm_vector","page":"CHMC","title":"MarkovWeightedEFMs.CHMC.Standard.reshape_efm_vector","text":"reshape_efm_vector(ϕ::Vector{Vector{Int64}}, S::Matrix{<:Real})\n\nConvert nested vector of EFM indices ϕ with length k to an n by k matrix of EFMs based on m by n stoichiometry matrix S. Stoichiometry matrix may only contain unimolecular reactions.\n\nϕ is the nested vector of EFMs with length k and elements corresponding to EFM metabolite indices in S.\n\nS is the m by n stoichiometry matrix with m metabolites (rows) and n reactions (cols).\n\nExamples\n\njulia> ϕ = [#\n  [1, 2, 3, 5, 6, 1],\n  [1, 2, 4, 5, 6, 1],\n  [2, 3, 2], [3, 5, 3], [5, 7, 5], [2, 4, 5, 3, 2]\n]\njulia> S = [#\n  -1  0  0  0  0  0  0  0  0  0  1\n   1 -1  1 -1  0  0  0  0  0  0  0\n   0  1 -1  0 -1  1  0  0  0  0  0\n   0  0  0  1  0  0 -1  0  0  0  0\n   0  0  0  0  1 -1  1 -1 -1  1  0\n   0  0  0  0  0  0  0  1  0  0 -1\n   0  0  0  0  0  0  0  0  1 -1  0\n]\njulia> efm_matrix = reshape_efm_vector(ϕ, S)\n11x6 Matrix{Int64}:\n 1  1  0  0  0  0\n 1  0  1  0  0  0\n 0  0  1  0  0  1\n 0  1  0  0  0  1\n 1  0  0  1  0  0\n 0  0  0  1  0  1\n 0  1  0  0  0  1\n 1  1  0  0  0  0\n 0  0  0  0  1  0\n 0  0  0  0  1  0\n 1  1  0  0  0  0\n\n\n\n\n\n","category":"function"},{"location":"library/chmc-standard/#Index","page":"CHMC","title":"Index","text":"","category":"section"},{"location":"library/chmc-standard/","page":"CHMC","title":"CHMC","text":"Pages = [\"chmc-standard.md\"]","category":"page"},{"location":"#MarkovWeightedEFMs.jl","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"","category":"section"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"MarkovWeightedEFMs.jl is a package to decompose steady state metabolic fluxes onto elementary flux mode (EFM) weights and atomic elementary flux mode (AEFM) weights. EFM flux decomposition works only for closed-loop networks of unimolecular reactions. AEFM flux decomposition works on metabolic flux networks with known metabolite structures.","category":"page"},{"location":"#Usage","page":"MarkovWeightedEFMs.jl","title":"Usage","text":"","category":"section"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"See Getting started for package installation and Python dependencies (RXNMapper) for AEFM enumeration and flux decomposition. Once installed, the package is loaded in a julia session by typing:","category":"page"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"julia> using MarkovWeightedEFMs","category":"page"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"See the tutorial sections for EFM or AEFM enumeration and flux decomposition.","category":"page"},{"location":"#Citing-MarkovWeightedEFMs.jl","page":"MarkovWeightedEFMs.jl","title":"Citing MarkovWeightedEFMs.jl","text":"","category":"section"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"Please cite the following papers if you use our method for (A)EFM enumeration and flux decomposition.","category":"page"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"Justin G. Chitpin and Theodore J. Perkins, Atomic elementary flux modes explain the steady state flow of metabolites in flux networks. biorXiv preprint doi: XX.XXXX/XXXX.XX.XX.XXXXXX","category":"page"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"Justin G. Chitpin and Theodore J. Perkins, A Markov constraint to uniquely identify elementary flux mode weights in unimolecular metabolic networks. J Theor Biol. 2023 Nov 7;575:111632. doi: 10.1016/j.jtbi.2023.111632","category":"page"},{"location":"#License","page":"MarkovWeightedEFMs.jl","title":"License","text":"","category":"section"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"This software is released under the MIT license.","category":"page"},{"location":"#Contact-information","page":"MarkovWeightedEFMs.jl","title":"Contact information","text":"","category":"section"},{"location":"","page":"MarkovWeightedEFMs.jl","title":"MarkovWeightedEFMs.jl","text":"Justin G. Chitpin at jchit069@uottawa.ca for questions.","category":"page"},{"location":"installation/installation/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"To install this package, open a julia session and enter:","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"julia> ]\n(@v1.10) pkg> add https://github.com/jchitpin/MarkovWeightedEFMs.jl.git","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"Alternatively, you can load Pkg and install by:","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"julia> using Pkg\njulia> Pkg.add(\"https://github.com/jchitpin/MarkovWeightedEFMs.jl.git\")","category":"page"},{"location":"installation/installation/#Python-dependencies-for-AEFM-analysis","page":"Getting started","title":"Python dependencies for AEFM analysis","text":"","category":"section"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"AEFM-specific analyses depend on the atom mapping program RXNMapper. This package must be installed and built with PyCall.jl after installing MarkovWeightedEFMs.jl. Tested with python version 3.10","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"This can be done by creating a python virtual environment, installing RXNMapper, and setting the PYTHON environment variable to the python executable in the virtual environment.","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"$ pip install virtualenv\n$ virtualenv --python=\"/usr/bin/python3.10\" \"virtualenv\" # name of virtual environment\n$ source virtualenv/bin/activate\n(virtualenv) $ pip install rxnmapper\n(virtualenv) $ pip install rdkit\n(virtualenv) $ pip install requests\n(virtualenv) $ pip install tdqm\n(virtualenv) $ pip install bs4\n(virtualenv) $ pip install CTSgetPy\n(virtualenv) $ julia","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"julia> using Pkg, PyCall\njulia> ENV[\"PYTHON\"] = joinpath(ENV[\"VIRTUAL_ENV\"], \"bin\", \"python\")\njulia> Pkg.build(\"PyCall\")","category":"page"},{"location":"installation/installation/","page":"Getting started","title":"Getting started","text":"Note PyCall.jl will need to be rebuilt whenever you update your Julia version. See PyCall.jl documentation for more options on setting up Python in Julia.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#ACHMC-(for-AEFMs)","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"This section shows how to use the functions in MarkovWeightedEFMs.jl to enumerate and assign AEFMs weights in a simple multispecies reaction network.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"(Image: Toy multispecies network)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#Inputs","page":"ACHMC (for AEFMs)","title":"Inputs","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"using MarkovWeightedEFMs\nS = [#\n  1 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0 # Glc\n  0 -1  0  0  0 -1  0  0  0  0  0  0  1  0  0  0 # ATP\n  0  1 -1  0 -1  0  0  0  0  0  0  0  0  0  0  0 # G6P\n  0  1  0  0  0  1  0  0  0  0  0  0  0 -1  0  0 # ADP\n  0  0  1 -1  0  0  0  0  0  0  0  0  0  0  0  0 # 6PG\n  0  0  0  0  1 -1  1  0  0  0  0  0  0  0  0  0 # F6P\n  0  0  0  0  0  0  1  0  0  0  0  0  0  0 -1  0 # Pi\n  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  1 # H2O\n  0  0  0  0  0  1 -1 -1  0  0  0  0  0  0  0  0 # FDP\n  0  0  0  0  0  0  0  1 -1  1 -1  0  0  0  0  0 # G3P\n  0  0  0  0  0  0  0  1  1 -1  0 -1  0  0  0  0 # DHAP\n]\n\nv = [10, 10, 3, 3, 7, 8, 1, 7, 1, 1, 7, 7, 18, 18, 1, 1]\n\nmets = [#\n  \"Glc\",\n  \"ATP\",\n  \"G6P\",\n  \"ADP\",\n  \"6PG\",\n  \"F6P\",\n  \"Pi\",\n  \"H2O\",\n  \"FDP\",\n  \"G3P\",\n  \"DHAP\"\n]\n\nrxns = [#\n  \"Source Glc\",\n  \"Hexokinase\",\n  \"G6P dehydrogenase\",\n  \"Sink 6PG\",\n  \"Phosphoglucose isomerase\",\n  \"6-phosphofructo-1-kinase\",\n  \"Fructose 1,6-bisphosphatase\",\n  \"Fructose-bisphosphate aldolase\",\n  \"Triose phosphate isomerase\",\n  \"Triose phosphate isomerase\",\n  \"Sink G3P\",\n  \"Sink DHAP\",\n  \"Source ATP\",\n  \"Sink ADP\",\n  \"Sink Pi\",\n  \"Source H2O\"\n]\n\nsmiles = [#\n  \"C([C@@H]1[C@H]([C@@H]([C@H](C(O1)O)O)O)O)O\",\n  \"C1=NC(=C2C(=N1)N(C=N2)[C@H]3[C@@H]([C@@H]([C@H](O3)COP(=O)(O)OP(=O)(O)OP(=O)(O)O)O)O)N\",\n  \"C([C@@H]1[C@H]([C@@H]([C@H](C(O1)O)O)O)O)OP(=O)(O)O\",\n  \"C1=NC(=C2C(=N1)N(C=N2)[C@H]3[C@@H]([C@@H]([C@H](O3)COP(=O)(O)OP(=O)(O)O)O)O)N\",\n  \"O=C1O[C@H](COP(=O)(O)O)[C@@H](O)[C@H](O)[C@H]1O\",\n  \"C([C@H]([C@H]([C@@H](C(=O)CO)O)O)O)OP(=O)(O)O\",\n  \"[O-]P(=O)([O-])[O-]\",\n  \"O\",\n  \"C(C1C(C(C(O1)(COP(=O)(O)O)O)O)O)OP(=O)(O)O\",\n  \"C([C@H](C=O)O)OP(=O)(O)O\",\n  \"C(C(=O)COP(=O)(O)O)O\"\n]","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"We can check that the flux vector satisfies the steady state requirements.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"all(S * v .== 0) # should evaluate as true","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#Pre-processing-data","page":"ACHMC (for AEFMs)","title":"Pre-processing data","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"The following functions check for issues with the inputs. The first function find_atomic_chmc_input_errors identifies possible problems with the stoichiometry matrix and flux vector. These problems, except for the steady state flux requirement, can be addressed via correct_atomic_chmc_input_errors. Finally, the last function correct_atomic_chmc_input_smiles checks and fixes problems relating to the SMILES strings.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"# Confirm there are no issues with stoichiometry matrix \nerrors = find_atomic_chmc_input_errors(S, v)\nprint(errors) # summary of errors associated with S/v\n\n# S and v have no errors so the inputs are returned\ncorrect_atomic_chmc_input_errors(errors, S, mets, rxns)\n# S, mets, rxns = correct_atomic_chmc_input_errors(errors, S, mets, rxns) # otherwise\n\n# Correct issues associated with RXNMapper character limit and pseudometabolites\nS, v, mets, rxns, smiles, logs = correct_atomic_chmc_input_smiles(S, v, mets, rxns, smiles)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"At this point, the SMILES strings (matching the updated mets if there were errors in the initial inputs) should be canonicalized.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"smiles = canonicalize_smiles(smiles)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#Atom-mapping-reactions","page":"ACHMC (for AEFMs)","title":"Atom mapping reactions","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"The reaction SMILES strings are next constructed from the metabolite SMILES and the atom mapping is performed via RXNMapper. In this tutorial, we will be constructing an atomic CHMC rooted on a particular source metabolite carbon. We precompute an atom tracing dictionary mapping the (carbon) atom in the stoichiometric copy of a substrate to its product across each reaction.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"# Construct atom traced SMILES strings\nrs, ms = map_reaction_strings(S, smiles, rxns, false)\n\n# Precompute atom tracing dictionary\natom = :C # carbon\natom_max = get_max_atoms(smiles, atom)\nD_C = precompute_atom_tracing_dictionary(S, ms, atom_max, atom)\n\n# Identify source metabolites\nsrc_mets = get_source_metabolites(S)\nmax_src_met_carbons = atom_max[src_mets]\nnothing # hide","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#Computing-ACHMC-for-a-given-metabolite/carbon-atom-state","page":"ACHMC (for AEFMs)","title":"Computing ACHMC for a given metabolite/carbon atom state","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"The following atomic CHMC is rooted on the first carbon atom of the first source metabolite in the stoichiometry matrix 6-phospho-D-gluconate.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"I = (src_mets[1], 1, atom) # initial state is 1st carbon of canonicalized glucose\nres = steady_state_efm_distribution(S, v, ms, I, D_C; verbose = false)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"If we only wanted to enumerate the AEFMs, we would run:","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"enumerate_atomic_efms(S, ms, I, D_C, verbose = false)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"Both functions produce the same output structure res, except that the AEFM flux decomposition field will be a vector of zeros.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#Converting-AEFM-to-sequence-of-metabolites","page":"ACHMC (for AEFMs)","title":"Converting AEFM to sequence of metabolites","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"The corresponding AEFMs correspond to the movement of metabolite/atom states through the reaction network. We can convert these states into metabolites using get_efm_metabolite_atom_indices.  Note that there is one fewer metabolite name than AEFM metabolite indices because the pseudometabolite (0, 0) linking sink and source reactions is omitted.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"# First AEFM\nmets[first.(get_efm_metabolite_atom_indices(res, 1))]","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"# Second AEFM\nmets[first.(get_efm_metabolite_atom_indices(res, 2))]","category":"page"},{"location":"tutorials/chmc-atomic-glucose/#Visualizing-the-CHMC-and-mapped-reactions","page":"ACHMC (for AEFMs)","title":"Visualizing the CHMC and mapped reactions","text":"","category":"section"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"The following plotting function visualizes the ACHMC rooted on state I. This is only recommended for exploring ACHMCs of small networks.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"using GLMakie # Makie backend\nGLMakie.activate!()\n\nplot_atomic_chmc(res, S, mets, rs)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"Each node in the main panel corresponds to a CHMC state (metabolite and atomic index).","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"(Image: ACHMC main panel)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"Clicking on a CHMC transition will highlight that transition and display the corresponding metabolic reaction on the upper panel. The pair of purple highlighted atoms correspond to the movement of the same atom from the LHS to RHS of the reaction.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"(Image: ACHMC main and upper panel)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"Finally, the reaction and mapped reaction SMILES strings can also be plotted as an SVG and previewed using a package like ElectronDisplay. If fname != \"\", the SVG is also saved to file. By default, fname == \"\" and the SVG is not saved.","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"using ElectronDisplay\n\n# Reaction string\nplot_mapped_reaction(rs[2], view=true)\n#plot_mapped_reaction(rs[2], \"\\path\\to\\save\\name.svg\", view=true)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"(Image: Reaction SMILES string)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"# Mapped reaction string\nplot_mapped_reaction(ms[2], view=true)\n#plot_mapped_reaction(ms[2], \"\\path\\to\\save\\name.svg\", view=true)","category":"page"},{"location":"tutorials/chmc-atomic-glucose/","page":"ACHMC (for AEFMs)","title":"ACHMC (for AEFMs)","text":"(Image: Mapped reaction SMILES string)","category":"page"}]
}
